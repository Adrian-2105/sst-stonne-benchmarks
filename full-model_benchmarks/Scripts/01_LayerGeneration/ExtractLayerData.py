import os, sys
import argparse
import re
import json

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from SstStonneBenchmarkUtils import MemFileFormatLib as sstlib
from SstStonneBenchmarkUtils import LayerDataFilenames

"""
Given a folder containing the information of a layer for each operation
(inner_product_m, outer_product_m, gustavsons_m; generated by the original
scripts to extract matrices and generate that dataflow clases), extracts all
useful information, containing it in a new dir called "layer_data". Also, it
generates all other useful information from the original data as described below.

The information extracted is:
    - Matrix A bitmap row-major, Matrix B bitmap col-major
    - Matrix A CSR and CSC format, Matrix B CSR format
    - Matrix A row-major and col-major mem file, Matrix B row-major and col-major mem file
The information generated is:
    - Matrix B CSC format
    - A JSON file containing the information of the layer (name, type, dimensions, etc)
    - SST Python scripts
"""

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Extracts all useful information from a layer')
    parser.add_argument('layer_dir', help='Directory containing the information of the layer')
    args = parser.parse_args()

    # check if dir exists
    assert os.path.isdir(args.layer_dir), f"Directory {args.layer_dir} does not exist"
    # check if dir contains the needed dirs
    assert os.path.isdir(os.path.join(args.layer_dir, "inner_product_m")), f"Directory {args.layer_dir} does not contain inner_product_m"
    assert os.path.isdir(os.path.join(args.layer_dir, "outer_product_m")), f"Directory {args.layer_dir} does not contain outer_product_m"
    assert os.path.isdir(os.path.join(args.layer_dir, "gustavsons_m")), f"Directory {args.layer_dir} does not contain gustavsons_m"

    # create dir to store the extracted data
    OUTPUT_DIR = os.path.join(args.layer_dir, "layer_data")
    if not os.path.isdir(OUTPUT_DIR):
        os.mkdir(OUTPUT_DIR)

    # get input filenames
    OLD_FILES = LayerDataFilenames.get_old_filenames(args.layer_dir)
    # get output filenames
    NEW_FILES = LayerDataFilenames.get_layer_data_filenames(OUTPUT_DIR)

    # copy files from the folders
    try:
        # 1. Extract the main information of the layer, generating a JSON file
        sst_file = open(OLD_FILES['IP-m_sst'], "r").read()
        LAYER_DATA = {}
        LAYER_DATA["name"] = os.path.basename(os.path.abspath(args.layer_dir))
        LAYER_DATA['M'] = int(re.search(r'"GEMM_M"\s*:\s*(\d+)', sst_file).group(1))
        LAYER_DATA['N'] = int(re.search(r'"GEMM_N"\s*:\s*(\d+)', sst_file).group(1))
        LAYER_DATA['K'] = int(re.search(r'"GEMM_K"\s*:\s*(\d+)', sst_file).group(1))
        LAYER_DATA['A_bytes'] = int(re.search(r'"matrix_b_dram_address"\s*:\s*(\d+)', sst_file).group(1))
        LAYER_DATA['B_bytes'] = int(re.search(r'"matrix_c_dram_address"\s*:\s*(\d+)', sst_file).group(1)) - LAYER_DATA['A_bytes']
        # save JSON
        with open(NEW_FILES['layer_info'], "w") as f:
            json.dump(LAYER_DATA, f, indent=4)


        # 2. Copy the files that can be copied directly
        # copy from inner_product_m
        os.system(f"cp {OLD_FILES['IP-m_A-bitmap']} {NEW_FILES['A-row-major-bitmap']}")
        os.system(f"cp {OLD_FILES['IP-m_B-bitmap']} {NEW_FILES['B-row-major-bitmap']}")
        os.system(f"cp {OLD_FILES['IP-m_sst']} {NEW_FILES['IP-m_sst']}")
        os.system(f"cp {OLD_FILES['IP-m_sst']} {NEW_FILES['IP-n_sst']}")
        os.system(f"cp {OLD_FILES['IP-m_arch']} {NEW_FILES['IP_arch']}")
        # copy from outer_product_m
        os.system(f"cp {OLD_FILES['OP-m_A-rowp']} {NEW_FILES['A-csc-rowp']}")
        os.system(f"cp {OLD_FILES['OP-m_A-colp']} {NEW_FILES['A-csc-colp']}")
        os.system(f"cp {OLD_FILES['OP-m_B-rowp']} {NEW_FILES['B-csr-rowp']}")
        os.system(f"cp {OLD_FILES['OP-m_B-colp']} {NEW_FILES['B-csr-colp']}")
        os.system(f"cp {OLD_FILES['OP-m_sst']} {NEW_FILES['OP-m_sst']}")
        os.system(f"cp {OLD_FILES['OP-m_sst']} {NEW_FILES['OP-n_sst']}")
        os.system(f"cp {OLD_FILES['OP-m_arch']} {NEW_FILES['OP_arch']}")
        # copy from gustavsons_m
        os.system(f"cp {OLD_FILES['Gust-m_A-rowp']} {NEW_FILES['A-csr-rowp']}")
        os.system(f"cp {OLD_FILES['Gust-m_A-colp']} {NEW_FILES['A-csr-colp']}")
        os.system(f"cp {OLD_FILES['Gust-m_sst']} {NEW_FILES['Gust-m_sst']}")
        os.system(f"cp {OLD_FILES['Gust-m_sst']} {NEW_FILES['Gust-n_sst']}")
        os.system(f"cp {OLD_FILES['Gust-m_arch']} {NEW_FILES['Gust_arch']}")


        # 3. Extract the mem files
        # extract A row-major and B col-major mem files
        memfile_csrcsc = sstlib.csv_read_file(OLD_FILES['IP-m_mem'])
        Arow, Bcol = sstlib.divide_mem(memfile_csrcsc, LAYER_DATA['A_bytes'], LAYER_DATA['B_bytes'])
        sstlib.csv_write_file(NEW_FILES['A-row_mem'], Arow, pack_data=True)
        sstlib.csv_write_file(NEW_FILES['B-col_mem'], Bcol, pack_data=True)
        # extract A col-major and B row-major mem files
        memfile_csccsr = sstlib.csv_read_file(OLD_FILES['OP-m_mem'])
        Acol, Bcol = sstlib.divide_mem(memfile_csccsr, LAYER_DATA['A_bytes'], LAYER_DATA['B_bytes'])
        sstlib.csv_write_file(NEW_FILES['A-col_mem'], Acol, pack_data=True)
        sstlib.csv_write_file(NEW_FILES['B-row_mem'], Bcol, pack_data=True)
    
        # 4. Generate the bitmaps col-major missing versions of the input matrices
        def generate_bitmap_col_major(input_file, output_file, rows, cols):
            bitmap_row = sstlib.csv_read_file(input_file, unpack_data=False, use_int=True)
            fake_data = [1 for _ in range(bitmap_row.count(1))]
            matrix = sstlib.matrix_sparsebitmap2dense(bitmap_row, fake_data, rows, cols)
            bitmap_col, _ = sstlib.matrix_dense2sparsebitmap(matrix.T)
            sstlib.csv_write_file(output_file, bitmap_col, pack_data=False, use_int=True)

        generate_bitmap_col_major(NEW_FILES['A-row-major-bitmap'], NEW_FILES['A-col-major-bitmap'], LAYER_DATA['M'], LAYER_DATA['K'])
        generate_bitmap_col_major(NEW_FILES['B-row-major-bitmap'], NEW_FILES['B-col-major-bitmap'], LAYER_DATA['K'], LAYER_DATA['N'])

        # 5. Generate the CSR/CSC missing versions of the input matrices
        # generate B CSC rowpointer and colpointer
        B_csr_rowp = sstlib.csv_read_file(NEW_FILES['B-csr-rowp'], unpack_data=False, use_int=True)
        B_csr_colp = sstlib.csv_read_file(NEW_FILES['B-csr-colp'], unpack_data=False, use_int=True)
        B_csr_data = sstlib.csv_read_file(NEW_FILES['B-row_mem'], unpack_data=True)
        B_matrix = sstlib.matrix_sparse2dense(B_csr_rowp, B_csr_colp, B_csr_data, LAYER_DATA['K'], LAYER_DATA['N'])
        B_csc_rowp, B_csc_colp, B_csc_data = sstlib.matrix_dense2sparse(B_matrix.T, LAYER_DATA['K'], LAYER_DATA['N'])
        sstlib.csv_write_file(NEW_FILES['B-csc-rowp'], B_csc_rowp, pack_data=False, use_int=True)
        sstlib.csv_write_file(NEW_FILES['B-csc-colp'], B_csc_colp, pack_data=False, use_int=True)


        # 5. Modify SST python scripts, prepared for all the different versions
        def set_sst_val(label, val, file, format_val=True):
            if format_val:
                if type(val) == str:
                    val = val.split('/')[-1]
                    val = f'"{val}"'
            sed = f'sed -i \'s/' # command start
            sed += f'\(\"{label}\" : \).*\(,\)/' # old text
            sed += f'\\1{val}\\2/' # new text
            sed += f'\' {file}' # file
            os.system(sed)

        # inner-product-m
        set_sst_val("GEMM_M", LAYER_DATA["M"], NEW_FILES['IP-m_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["N"], NEW_FILES['IP-m_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['IP-m_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["A_bytes"], NEW_FILES['IP-m_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_A-row_B-col'], NEW_FILES['IP-m_sst'])
        set_sst_val("bitmap_matrix_a_init", NEW_FILES['A-row-major-bitmap'], NEW_FILES['IP-m_sst'])
        set_sst_val("bitmap_matrix_b_init", NEW_FILES['B-row-major-bitmap'], NEW_FILES['IP-m_sst'])
        # inner-product-n
        set_sst_val("GEMM_M", LAYER_DATA["N"], NEW_FILES['IP-n_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["M"], NEW_FILES['IP-n_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['IP-n_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["B_bytes"], NEW_FILES['IP-n_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_B-col_A-row'], NEW_FILES['IP-n_sst'])
        set_sst_val("bitmap_matrix_a_init", NEW_FILES['B-row-major-bitmap'], NEW_FILES['IP-n_sst'])
        set_sst_val("bitmap_matrix_b_init", NEW_FILES['A-row-major-bitmap'], NEW_FILES['IP-n_sst'])
        # outer-product-m
        set_sst_val("GEMM_M", LAYER_DATA["M"], NEW_FILES['OP-m_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["N"], NEW_FILES['OP-m_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['OP-m_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["A_bytes"], NEW_FILES['OP-m_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_A-col_B-row'], NEW_FILES['OP-m_sst'])
        set_sst_val("rowpointer_matrix_a_init", NEW_FILES['A-csc-rowp'], NEW_FILES['OP-m_sst'])
        set_sst_val("colpointer_matrix_a_init", NEW_FILES['A-csc-colp'], NEW_FILES['OP-m_sst'])
        set_sst_val("rowpointer_matrix_b_init", NEW_FILES['B-csr-rowp'], NEW_FILES['OP-m_sst'])
        set_sst_val("colpointer_matrix_b_init", NEW_FILES['B-csr-colp'], NEW_FILES['OP-m_sst'])
        # outer-product-n
        set_sst_val("GEMM_M", LAYER_DATA["N"], NEW_FILES['OP-n_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["M"], NEW_FILES['OP-n_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['OP-n_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["B_bytes"], NEW_FILES['OP-n_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_B-row_A-col'], NEW_FILES['OP-n_sst'])
        set_sst_val("rowpointer_matrix_a_init", NEW_FILES['B-csr-rowp'], NEW_FILES['OP-n_sst'])
        set_sst_val("colpointer_matrix_a_init", NEW_FILES['B-csr-colp'], NEW_FILES['OP-n_sst'])
        set_sst_val("rowpointer_matrix_b_init", NEW_FILES['A-csc-rowp'], NEW_FILES['OP-n_sst'])
        set_sst_val("colpointer_matrix_b_init", NEW_FILES['A-csc-colp'], NEW_FILES['OP-n_sst'])
        # gustavsons-m
        set_sst_val("GEMM_M", LAYER_DATA["M"], NEW_FILES['Gust-m_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["N"], NEW_FILES['Gust-m_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['Gust-m_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["A_bytes"], NEW_FILES['Gust-m_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_A-row_B-row'], NEW_FILES['Gust-m_sst'])
        set_sst_val("rowpointer_matrix_a_init", NEW_FILES['A-csr-rowp'], NEW_FILES['Gust-m_sst'])
        set_sst_val("colpointer_matrix_a_init", NEW_FILES['A-csr-colp'], NEW_FILES['Gust-m_sst'])
        set_sst_val("rowpointer_matrix_b_init", NEW_FILES['B-csr-rowp'], NEW_FILES['Gust-m_sst'])
        set_sst_val("colpointer_matrix_b_init", NEW_FILES['B-csr-colp'], NEW_FILES['Gust-m_sst'])
        # gustavsons-n
        set_sst_val("GEMM_M", LAYER_DATA["N"], NEW_FILES['Gust-n_sst'])
        set_sst_val("GEMM_N", LAYER_DATA["M"], NEW_FILES['Gust-n_sst'])
        set_sst_val("GEMM_K", LAYER_DATA["K"], NEW_FILES['Gust-n_sst'])
        set_sst_val("matrix_b_dram_address", LAYER_DATA["B_bytes"], NEW_FILES['Gust-n_sst'])
        set_sst_val("mem_init", NEW_FILES['mem_B-col_A-col'], NEW_FILES['Gust-n_sst'])
        set_sst_val("rowpointer_matrix_a_init", NEW_FILES['B-csc-rowp'], NEW_FILES['Gust-n_sst'])
        set_sst_val("colpointer_matrix_a_init", NEW_FILES['B-csc-colp'], NEW_FILES['Gust-n_sst'])
        set_sst_val("rowpointer_matrix_b_init", NEW_FILES['A-csc-rowp'], NEW_FILES['Gust-n_sst'])
        set_sst_val("colpointer_matrix_b_init", NEW_FILES['A-csc-colp'], NEW_FILES['Gust-n_sst'])




    except Exception as e:
        print(e.__traceback__.tb_lineno, e)
        print("FATAL ERROR: Error while extracting data from layer")
        exit(1)
